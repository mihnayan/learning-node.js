#Записки в процессе изучения node.js

##Объект exports

Объект `exports` используется для экспортирования функций модуля. Например, в модуле `server.js` объявляем функцию `start` и экспортируем ее под этим же именем:

	//server.js
	function start(route) {
		// some code...
	}
	
	exports.start = start;

Тогда в модуле, например, `index.js` можно подключив модуль `server.js` использовать функцию `start`:

	//index.js
	var server = require("./server");
	
	server.start(router);

При этом здесь используется не имя функции в модуле `server.js`, а имя, используемое при определении в объекте `exports`. Например, если бы в модуле `server.js` было бы записано:

	exports.run = start;

то модуль `index.js` следовало бы изменить следующим образом:

	//index.js
	var server = require("./server");
	
	server.run(router);

То есть, при этом в строке `server.run(router)` вызывается функция `start()` модуля `server.js`.

##Асинхронная обработка запросов
(Пункт составлен на основе статьи [Understanding the node.js event loop](http://blog.mixu.net/2011/02/01/understanding-the-node-js-event-loop/))
 
Весь код в Node.js исполняется в одном потоке, что исключает возможную перегрузку сервера, которая может создаваться тысячами потоками/процессами. Тем не менее, операции ввода/вывода (I/O) выполняются в node.js параллельно. Это позволяет реализовать асинхронную обработку запросов, основанную на событийной (event-based) модели, с применением функций обратного вызова (callback). В частности, именно такой метод рекомендуется применять при блокирующих операциях (долгие вычисления, запросы к базе данный и т.п.).

##Относительно кодировки
Однажды понадобилось установить кодировку символов отличную от умалчиваемой (в методе `response.write()`).

[Вот ссылка на список кодировок](https://github.com/joyent/node/blob/5a5a98d0d8281f6901b7e9dac285d59ab3e39b95/lib/buffer.js#L126), которая найдена в [ответе на Stackoverflow.com](http://stackoverflow.com/questions/14551608/cant-find-encodings-for-node-js).
